#version 430

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba16, binding = 0) uniform image2D imgInput16bit; // Note: this needs to match what it is writing to
layout(rgba8, binding = 1) uniform image2D imgInput8bit; // Note: this needs to match what it is writing to

layout(std430, binding = 2) buffer buffer_layout
{
    uint bufferOutput[];
};

layout(std430, binding = 3) buffer description_layout
{
    // This must match convert_from_texture_description in device.h
    bool is_16_bit;
    uint frame_width;
    uint frame_height;
    uint words_per_line;
};

vec4 read_pixel(ivec2 coord) {
    if (is_16_bit){
        return imageLoad(imgInput16bit, coord);
    } else {
        return imageLoad(imgInput8bit, coord);
    }
}

vec3 rgba_to_bt709(vec4 pixel) {
    float KR = 0.2126;
    float KB = 0.0722;
    float KG = 1.0 - KR - KB;

    float KRi = 1.0 - KR;
    float KBi = 1.0 - KB;

    float YRange = 219.0 / 256.0;
    float CbCrRange = 224.0 / 256.0;
    float HalfCbCrRange = CbCrRange / 2.0;

    float YOffset = 16.0 / 256.0;
    float CbCrOffset = 0.5;

    float KRoKBi = KR / KBi;
    float KGoKBi = KG / KBi;
    float KBoKRi = KB / KRi;
    float KGoKRi = KG / KRi;

//    vec3 y_range = vec3(KR * YRange, KG * YRange, KB * YRange);
//    vec3 y_offset = vec3(YOffset, YOffset, YOffset);

    float y16 = KR * pixel.r + KG * pixel.g + KB * pixel.b;
    float y = (YOffset + y16 * YRange);

    float cb16 = -KRoKBi * pixel.r - KGoKBi * pixel.g + pixel.b;
    float cb = (CbCrOffset + cb16 * HalfCbCrRange);

    float cr16 = pixel.r - KGoKRi * pixel.g - KBoKRi * pixel.b;
    float cr = (CbCrOffset + cr16 * HalfCbCrRange);

    return vec3(y, cb, cr);
}

uint to_10bit(float val) {
    return uint(round(val * 1023));
}

void decklink_v210() {
    // basic coordinates
    uint y_offset = gl_GlobalInvocationID.y * words_per_line;
    uint x_offset = gl_GlobalInvocationID.x * 4; // 4 bytes per op
    uint offset = y_offset + x_offset;
    uint image_x = gl_GlobalInvocationID.x * 6;

    // sample image and compute words
    vec3 ycbcr0 = rgba_to_bt709(read_pixel(ivec2(image_x + 0, gl_GlobalInvocationID.y)));
    bufferOutput[offset + 0] = to_10bit(ycbcr0.t) + (to_10bit(ycbcr0.s) << 10) + (to_10bit(ycbcr0.p) << 20);

    vec3 ycbcr1 = rgba_to_bt709(read_pixel(ivec2(image_x + 1, gl_GlobalInvocationID.y)));
    vec3 ycbcr2 = rgba_to_bt709(read_pixel(ivec2(image_x + 2, gl_GlobalInvocationID.y)));
    bufferOutput[offset + 1] = to_10bit(ycbcr1.s) + (to_10bit(ycbcr2.t) << 10) + (to_10bit(ycbcr2.s) << 20);

    vec3 ycbcr3 = rgba_to_bt709(read_pixel(ivec2(image_x + 3, gl_GlobalInvocationID.y)));
    vec3 ycbcr4 = rgba_to_bt709(read_pixel(ivec2(image_x + 4, gl_GlobalInvocationID.y)));
    bufferOutput[offset + 2] = to_10bit(ycbcr2.p) + (to_10bit(ycbcr3.s) << 10) + (to_10bit(ycbcr4.t) << 20);

    vec3 ycbcr5 = rgba_to_bt709(read_pixel(ivec2(image_x + 5, gl_GlobalInvocationID.y)));
    bufferOutput[offset + 3] = to_10bit(ycbcr4.s) + (to_10bit(ycbcr4.p) << 10) + (to_10bit(ycbcr5.s) << 20);
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

    decklink_v210();
}