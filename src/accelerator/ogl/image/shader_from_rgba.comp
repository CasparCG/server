/*
 * Copyright (c) 2011 Sveriges Television AB <info@casparcg.com>
 *
 * This file is part of CasparCG (www.casparcg.com).
 *
 * CasparCG is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * CasparCG is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with CasparCG. If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Julian Waller, julian@superfly.tv
 */
#version 430

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba16, binding = 0) uniform image2D imgInput16bit; // Note: this needs to match what it is writing to
layout(rgba8, binding = 1) uniform image2D imgInput8bit; // Note: this needs to match what it is writing to

layout(std430, binding = 2) buffer buffer_layout
{
    uint bufferOutput[];
};

layout(std430, binding = 3) buffer description_layout
{
    // This must match convert_from_texture_description in device.h
    uint target_format;
    uint is_16_bit;
    uint frame_width;
    uint frame_height;
    uint words_per_line;
    uint key_only;
    uint straigthen;
};

vec4 straighten_pixel(vec4 pixel) {
    return vec4(
        pixel.r / pixel.a,
        pixel.g / pixel.a,
        pixel.b / pixel.a,
        pixel.a
    );
}

vec4 read_pixel(ivec2 coord) {
    vec4 pixel = is_16_bit > 0 ? imageLoad(imgInput16bit, coord) : imageLoad(imgInput8bit, coord);
    if (key_only > 0) return pixel.aaaa;
    if (straigthen > 0) return straighten_pixel(pixel);
    return pixel;
}

vec3 rgba_to_bt709(vec4 pixel) {
    if (key_only > 0) {
        // TODO - verify everything about this
        return vec3(pixel.a, 0.5, 0.5);
    }

    float KR = 0.2126;
    float KB = 0.0722;
    float KG = 1.0 - KR - KB;

    float KRi = 1.0 - KR;
    float KBi = 1.0 - KB;

    float YRange = 219.0 / 256.0;
    float CbCrRange = 224.0 / 256.0;
    float HalfCbCrRange = CbCrRange / 2.0;

    float YOffset = 16.0 / 256.0;
    float CbCrOffset = 0.5;

    float KRoKBi = KR / KBi;
    float KGoKBi = KG / KBi;
    float KBoKRi = KB / KRi;
    float KGoKRi = KG / KRi;

//    vec3 y_range = vec3(KR * YRange, KG * YRange, KB * YRange);
//    vec3 y_offset = vec3(YOffset, YOffset, YOffset);

    float y16 = KR * pixel.r + KG * pixel.g + KB * pixel.b;
    float y = (YOffset + y16 * YRange);

    float cb16 = -KRoKBi * pixel.r - KGoKBi * pixel.g + pixel.b;
    float cb = (CbCrOffset + cb16 * HalfCbCrRange);

    float cr16 = pixel.r - KGoKRi * pixel.g - KBoKRi * pixel.b;
    float cr = (CbCrOffset + cr16 * HalfCbCrRange);

    return vec3(y, cb, cr);
}

uint to_10bit(float val) {
    return uint(round(val * 1023));
}

void decklink_v210() {
    // basic coordinates
    uint y_offset = gl_GlobalInvocationID.y * words_per_line;
    uint x_offset = gl_GlobalInvocationID.x * 4; // 4 words per op
    uint offset = y_offset + x_offset;
    uint image_x = gl_GlobalInvocationID.x * 6;

    // sample image and compute words
    vec3 ycbcr0 = rgba_to_bt709(read_pixel(ivec2(image_x + 0, gl_GlobalInvocationID.y)));
    bufferOutput[offset + 0] = to_10bit(ycbcr0.t) + (to_10bit(ycbcr0.s) << 10) + (to_10bit(ycbcr0.p) << 20);

    vec3 ycbcr1 = rgba_to_bt709(read_pixel(ivec2(image_x + 1, gl_GlobalInvocationID.y)));
    vec3 ycbcr2 = rgba_to_bt709(read_pixel(ivec2(image_x + 2, gl_GlobalInvocationID.y)));
    bufferOutput[offset + 1] = to_10bit(ycbcr1.s) + (to_10bit(ycbcr2.t) << 10) + (to_10bit(ycbcr2.s) << 20);

    vec3 ycbcr3 = rgba_to_bt709(read_pixel(ivec2(image_x + 3, gl_GlobalInvocationID.y)));
    vec3 ycbcr4 = rgba_to_bt709(read_pixel(ivec2(image_x + 4, gl_GlobalInvocationID.y)));
    bufferOutput[offset + 2] = to_10bit(ycbcr2.p) + (to_10bit(ycbcr3.s) << 10) + (to_10bit(ycbcr4.t) << 20);

    vec3 ycbcr5 = rgba_to_bt709(read_pixel(ivec2(image_x + 5, gl_GlobalInvocationID.y)));
    bufferOutput[offset + 3] = to_10bit(ycbcr4.s) + (to_10bit(ycbcr4.p) << 10) + (to_10bit(ycbcr5.s) << 20);
}


void rgba16() {
    // TODO: is this excessive to do in a shader?
    // basic coordinates
    uint y_offset = gl_GlobalInvocationID.y * words_per_line;
    uint x_offset = gl_GlobalInvocationID.x * 2; // 4 words per op
    uint offset = y_offset + x_offset;

    // TODO - can this be done solely as integer?
    vec4 pixel = read_pixel(ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y));

    bufferOutput[offset + 0] = uint(pixel.r * 65535) + (uint(pixel.g * 65535) << 16);
    bufferOutput[offset + 1] = uint(pixel.b * 65535) + (uint(pixel.a * 65535) << 16);
}

void bgra16() {
    // TODO: is this excessive to do in a shader?
    // basic coordinates
    uint y_offset = gl_GlobalInvocationID.y * words_per_line;
    uint x_offset = gl_GlobalInvocationID.x * 2; // 4 words per op
    uint offset = y_offset + x_offset;

    // TODO - can this be done solely as integer?
    vec4 pixel = read_pixel(ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y));

    bufferOutput[offset + 0] = uint(pixel.b * 65535) + (uint(pixel.g * 65535) << 16);
    bufferOutput[offset + 1] = uint(pixel.r * 65535) + (uint(pixel.a * 65535) << 16);
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

    switch(target_format){
        case 0: // rgba16
            rgba16();
            break;
        case 1: // bgra16
            bgra16();
            break;

        case 2:
            decklink_v210();
            break;
    }
}